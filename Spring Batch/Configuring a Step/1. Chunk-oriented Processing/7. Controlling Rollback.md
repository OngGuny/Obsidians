기본적으로 `Retry` 또는 `Skip`과 관계없이 `ItemWriter`에서 발생한 예외로 인해  `Step`에 의해 제어되는 트랜잭션이 `Rollback`됩니다. 앞에서 설명한 대로 `Skip`을 구성한 경우 `ItemReader`에서 발생한 예외로 인해 `Rollback`이 발생하지 않습니다. 
**그러나** 트랜잭션을 무효화하는 action이 수행되지 않았기 때문에 `ItemWriter`에서 발생한 예외로 인해 `Rollback`이 발생하지 않아야 하는 시나리오가 많이 있습니다. 이러한 이유로 `Rollback`을 발생시키지 않아야 하는 예외 목록을 사용하여 `Step`을 구성할 수 있습니다.

---GPT 예시
### 롤백이 필요 없는 상황

1. **비즈니스 로직 예외**:
    - 예를 들어, 특정 데이터가 비즈니스 로직에 의해 유효하지 않다고 판단되어 `ItemWriter`에서 예외를 던진 경우입니다. 이런 경우에는 데이터가 잘못된 것이지 트랜잭션 자체가 무효화된 것은 아닙니다.
    - 예시: 중복 데이터, 데이터 포맷 문제 등.
2. **데이터 중복 예외**:
    - 이미 존재하는 데이터에 대해 `UniqueConstraintViolationException`과 같은 예외가 발생한 경우입니다. 이 경우 데이터베이스 상태는 여전히 일관성을 유지하고 있으며, 단순히 데이터가 중복된 것 뿐입니다.
3. **외부 시스템 예외**:
    - 외부 API 호출이 실패했지만, 이는 재시도를 통해 해결할 수 있는 문제인 경우입니다. 이때, 트랜잭션을 롤백할 필요는 없을 수 있습니다.

### 무효화되지 않은 경우 발생할 수 있는 문제

1. **데이터 불일치**:
    - 트랜잭션이 무효화되지 않았다고 잘못 판단하여 롤백하지 않으면 데이터베이스의 상태와 실제로 원하는 상태가 불일치할 수 있습니다.
    - 예시: `ItemWriter`에서 중복 데이터를 무시하고 넘어갔으나, 트랜잭션이 롤백되지 않아 중복 데이터가 데이터베이스에 남는 경우.
2. **데이터 손실**:
    - 잘못된 데이터를 필터링하기 위해 예외를 던졌는데 롤백되지 않으면, 해당 데이터가 누락되거나 손실될 수 있습니다.
3. **일관성 문제**:
    - 외부 시스템과 연동된 작업에서 예외가 발생했는데 트랜잭션이 롤백되지 않으면, 데이터베이스의 상태와 외부 시스템의 상태가 일치하지 않을 수 있습니다.
4. **재시도 로직의 실패**:
    - 롤백이 되어야 하는 상황에서 롤백이 되지 않으면, 재시도 로직이 제대로 작동하지 않아 동일한 오류가 반복될 수 있습니다.


# Transactional Readers
ItemReader의 기본 계약은 전달 전용이라는 것입니다. 이 단계는 롤백 시 판독기에서 항목을 다시 읽을 필요가 없도록 판독기 입력을 버퍼링합니다. 그러나 리더가 JMS 대기열과 같은 트랜잭션 리소스 위에 구축되는 특정 시나리오가 있습니다. 이 경우 대기열은 롤백되는 트랜잭션에 연결되어 있으므로 대기열에서 가져온 메시지가 다시 배치됩니다. 이러한 이유로 항목을 버퍼링하지 않도록 단계를 구성할 수 있습니다.

이런 어려운설명. 이해하지못해.

---GPT 설명
### 기본 개념 설명

1. **ItemReader**:
    - Spring Batch에서 데이터를 읽어오는 역할을 합니다. 기본적으로 앞으로만 이동하며 데이터를 읽습니다.
2. **버퍼링**:
    - Spring Batch의 Step이 데이터를 읽을 때, 만약 예외가 발생해 트랜잭션이 롤백되면, 읽었던 데이터를 다시 읽지 않기 위해 데이터를 버퍼에 저장해 둡니다.
3. **트랜잭셔널 리소스**:
    - JMS 큐와 같은 트랜잭셔널 리소스는 트랜잭션과 함께 동작합니다. 즉, 트랜잭션이 롤백되면 큐에서 읽어온 메시지도 다시 큐로 돌아갑니다.

### 문제 상황

JMS 큐와 같은 트랜잭셔널 리소스를 사용하는 경우, 트랜잭션이 롤백되면 큐에서 이미 읽어온 메시지가 다시 큐로 돌아갑니다. 이 경우, Spring Batch가 데이터를 버퍼에 저장하지 않도록 설정해야 합니다. 그렇지 않으면 동일한 데이터를 두 번 처리하는 문제가 발생할 수 있습니다.

### 예시

예를 들어, JMS 큐에서 메시지를 읽어와 처리하는 배치 작업을 생각해 봅시다.

1. **트랜잭셔널 리소스를 사용하지 않는 경우**:
    - 배치 작업이 시작되면 JMS 큐에서 메시지 A, B, C를 순서대로 읽습니다.
    - 메시지 A와 B를 처리 중에 예외가 발생해 트랜잭션이 롤백됩니다.
    - Spring Batch는 메시지 A와 B를 버퍼에 저장해 두었기 때문에, 롤백 후 다시 A와 B를 처리하지 않습니다.
2. **트랜잭셔널 리소스를 사용하는 경우**:
    - 배치 작업이 시작되면 JMS 큐에서 메시지 A, B, C를 순서대로 읽습니다.
    - 메시지 A와 B를 처리 중에 예외가 발생해 트랜잭션이 롤백됩니다.
    - 트랜잭션 롤백으로 인해 메시지 A와 B는 다시 큐로 돌아갑니다.
    - Spring Batch는 버퍼를 사용하지 않도록 설정되어 있으므로, 메시지 A와 B를 다시 큐에서 읽어옵니다.

따라서, JMS 큐와 같은 트랜잭셔널 리소스를 사용하는 경우, 버퍼링을 사용하지 않도록 설정해야 동일한 메시지를 두 번 처리하지 않게 됩니다.

### 코드 예시

다음은 Java Configuration을 통해 `readerIsTransactionalQueue`를 설정하는 예시입니다:

```java
@Bean
public Step step1(JobRepository jobRepository, PlatformTransactionManager transactionManager) {
    return new StepBuilder("step1", jobRepository)
                .<String, String>chunk(2, transactionManager)
                .reader(itemReader())  // JMS 큐에서 메시지를 읽어오는 리더
                .writer(itemWriter())  // 읽어온 메시지를 처리하는 라이터
                .readerIsTransactionalQueue()  // 트랜잭셔널 큐를 사용하도록 설정
                .build();
}

```
### 요약

- **ItemReader**는 데이터를 앞으로만 읽어옵니다.
- 기본적으로 Step은 데이터를 버퍼링해 트랜잭션 롤백 시 재처리를 방지합니다.
- JMS 큐와 같은 트랜잭셔널 리소스를 사용하는 경우, 트랜잭션이 롤백되면 메시지가 큐로 돌아가므로 버퍼링을 사용하지 않도록 설정해야 합니다.
- 이를 위해 `readerIsTransactionalQueue()` 메서드를 사용합니다.




## 추가 : 트랜잭셔널 리소스
### 트랜잭셔널 리소스의 개념

**트랜잭셔널 리소스**는 트랜잭션의 경계 내에서 동작하는 모든 자원입니다. 트랜잭션은 데이터베이스 연산, 메시지 큐의 메시지 처리, 파일 시스템의 파일 처리 등 여러 작업을 하나의 단위로 묶어서 모두 성공하거나 모두 실패하게 합니다. 트랜잭션 내의 모든 작업은 모두 성공적으로 완료되거나, 오류가 발생하면 모두 취소(롤백)됩니다.

#### 예시:

- **데이터베이스**: 데이터베이스 트랜잭션은 여러 SQL 연산을 하나의 단위로 묶어서, 중간에 오류가 발생하면 모든 변경 사항을 원래 상태로 되돌립니다.
- **메시지 큐**: JMS와 같은 메시지 큐에서는 트랜잭션이 완료될 때까지 메시지를 잠금 상태로 유지하고, 트랜잭션이 성공하면 메시지를 소비자에게 전달하며, 트랜잭션이 롤백되면 메시지를 큐로 되돌립니다.
- **파일 시스템**: 트랜잭션을 지원하는 파일 시스템에서는 여러 파일 작업을 하나의 단위로 묶어, 작업 중 하나라도 실패하면 모든 파일 변경을 되돌립니다.

### 트랜잭셔널 리소스 예시: JMS 큐

**JMS 큐**를 트랜잭셔널 리소스로 사용할 때의 동작을 설명하겠습니다.

1. **메시지 읽기**: JMS 큐에서 메시지를 읽어옵니다.
2. **트랜잭션 시작**: JMS 큐에서 메시지를 읽은 시점에 트랜잭션이 시작됩니다.
3. **메시지 처리**: 읽어온 메시지를 처리합니다.
4. **트랜잭션 완료**: 메시지 처리가 성공하면 트랜잭션을 커밋합니다. 이때 메시지는 큐에서 제거됩니다.
5. **트랜잭션 롤백**: 메시지 처리가 실패하면 트랜잭션을 롤백합니다. 이때 메시지는 큐로 되돌아갑니다.

### Spring Batch에서의 트랜잭셔널 리소스

Spring Batch에서는 Step 내에서 트랜잭션을 관리합니다. 일반적으로 ItemReader, ItemProcessor, ItemWriter가 트랜잭션 경계 내에서 동작합니다. 트랜잭셔널 리소스를 사용하는 경우, 트랜잭션이 롤백되면 해당 리소스의 상태도 롤백됩니다.

### 예시를 통한 설명

1. **비트랜잭셔널 리소스 사용 시**:
    
    - 데이터베이스에서 데이터를 읽어오는 ItemReader를 생각해 봅시다.
    - Step이 데이터를 읽고 처리하다가 예외가 발생해 트랜잭션이 롤백되면, Spring Batch는 데이터를 버퍼에 저장해 두었기 때문에, 롤백 후 데이터를 다시 읽지 않고 버퍼에서 데이터를 가져옵니다.
2. **트랜잭셔널 리소스 사용 시**:
    
    - JMS 큐에서 메시지를 읽어오는 ItemReader를 생각해 봅시다.
    - Step이 JMS 큐에서 메시지를 읽고 처리하다가 예외가 발생해 트랜잭션이 롤백되면, JMS 큐는 메시지를 다시 큐로 되돌립니다.
    - Spring Batch는 버퍼링을 사용하지 않도록 설정되어 있으므로, 롤백 후 다시 JMS 큐에서 메시지를 읽어옵니다.

결론 : 그래서 Step 에게 트랜잭셔널 큐 를 사용하라고 (되돌아간 item 을 다시 처리하지 않도록, 다시 처리하면 에러가 씹히거나, 계속 에러가 발생 등등) 알려줘야함. (되돌리지 말라고)